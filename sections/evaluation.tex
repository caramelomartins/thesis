\chapter{Evaluation}
\label{chap:evaluation}

This chapter provides an evaluation of the work developed in this thesis. Section \ref{sec:eval-analysis} offers a discussion of \texttt{Blocked} and compares it to existing systems, described in Chapter \ref{chap:related}. Section \ref{sec:eval-study} provides an analysis of the outcomes of the study conducted throughout Chapter \ref{chap:study}. Section \ref{sec:eval-ac} analyzes \texttt{Blocked}, as an access control system, through the guidelines proposed by \citeauthor{hu_guidelines_2012} \cite{hu_guidelines_2012} for evaluation of access control systems. Finally, Section \ref{sec:eval-limitations} describes existing limitations on the research that has been conducted.

\section{Discussion of \texttt{Blocked}}
\label{sec:eval-analysis}

\texttt{Blocked} has been developed with the objective of being used for a single use case. Due to this fact, some of its properties are specific to that use case. One such example is the way information is stored inside the blockchain. Although it could easily be adapted and extended, at the moment, \texttt{Blocked} is focused on the specific use case of issuing, sharing and managing access to educational certificates. The single use case that has been tested, and described in Chapter \ref{chap:implementation}, is that of issuing a certificate to a recipient and that recipient sharing the certificate with a third-party. This differs slightly with what has been proposed in \emph{BSCW}, focusing on archiving the certificate in a tamper-proof fashion, rather than on the sharing of those certificates, which is less clear and relies on the sharing of folders with PDF documents, that can later be verified. It also differs from what is proposed with \emph{BlockCerts}, which relies on storing a hash of the certificate on the blockchain, rather than the certificate itself. With the certificate having to be shared for verification against the hash that is stored in the Blockchain. At the same time, \emph{BSCW} also stores only a hash of the certificate with only a handful of properties on the blockchain. Both these solutions end up coming short of storing the entire contents of the certificates on the blockchain thus still relying on potentially centralized components for storage. In the end, both solutions end up having to share documents with third-parties for verification, due to the fact that only a few properties are stored in the blockchain, contrary to \texttt{Blocked}, potentially compromising the control of access to that information.

Another aspect of both \emph{BlockCerts} and \emph{BSCW} that differs from \texttt{Blocked} is the supported blockchain category. Both systems rely on permissionless blockchains - Bitcoin for \emph{BlockCerts} and \emph{BSCW}. \texttt{Blocked} relies on a permissioned blockchain - Hyperledger Sawtooth, which is a crucial difference from those projects. Permissioned blockchains are more suitable for organizational environments, such as our use case. They offer the following advantages: \emph{(i)} more flexibility in configuration; \emph{(ii)} enhanced control over the participants of the network - particularly, those with write permissions - enabling, for example, that only students be allowed to write to the blockchain, while third-parties are only able to read; \emph{(iii)} monetary costs are reduced because, contrary to existing permissionless blockchains, there's no cost associated with issuing a certificate on the blockchain. Research on blockchain-based access control \cite{maesa_blockchain_2017} also relies on permissionless blockchains, suffering from the same issues. Existing systems do not write sensible data on the blockchain but the fact that they don't doesn't enhance the security of the information because a document will still need to be shared with the information, for third-parties. \texttt{Blocked} overcomes this by encrypting the certificate information before storing it in the blockchain, avoiding writing sensitive information. This can potentially be applied on permissionless blockchains as well to allow storage of sensitive information in blockchains.

In terms of revocation capabilities, \texttt{Blocked} offers enhanced features, when compared with \emph{BlockCerts} and \emph{BSCW}, by allowing for revocation to be initiated by both the issuer or the recipient and still displaying the certificate information, even when revoked. \emph{BlockCerts} only supports issuer-based revocation while \emph{BSCW} supports revocation but can't display or use revoked certificates after revocation.

In terms of access control, \texttt{Blocked} achieves decentralized access control through cryptography and \gls{acl}s. Certificate information is encrypted with symmetric encryption and then a list of permissions is stored on the blockchain, through the form of an encrypted symmetric key. Whoever is on the list and can decrypt the symmetric key, will have access to the certificate's information. This solution is less scalable than other access control mechanisms but solves the existing use case, for information that is not meant to be shared with potentially hundreds of users and with policies that will not be changed with high-frequency. Compared to \citeauthor{maesa_blockchain_2017} \cite{maesa_blockchain_2017}, our system is very unsophisticated because it does not support \gls{abac} or any of its standards, as pointed out in Section \ref{sec:eval-ac}. This is potentially hindering in future iterations of the concept. At the same time, \emph{BlockCerts} does not provide any access control functionality, while \emph{BSCW} supports a degree of access control, through its document management system and \emph{smart contracts}, though it is unclear which mechanisms it uses - most of its information is publicly readable on the blockchain and \emph{read-only}. It is possible to control access of third-parties to verify a specific certificate if a user has not shared that certificate but the information in the blockchain is still readable.

One aspect in which \texttt{Blocked} is weaker than its counterparts is in the structure of the information. Although other systems don't store much information on the blockchain, both handle certificates through the Mozilla Open Badges specification \cite{openbadges}. This is a strength due to the fact that standardization is relevant for the well-being of a decentralized ecosystem. \texttt{Blocked}'s structure has been created specifically for this thesis.

In conclusion, while \text{Blocked} is still at a very early stage in its development, especially when compared to \emph{BlockCerts} and \emph{BSCW}, which are more mature, it demonstrates a potential for a different solution for decentralizing access control, on the case of issuing, sharing and managing educational certificates. This exploration demonstrates that permissionless blockchains, with embedded access control mechanisms, have the potential to provide a solution that will enable users to complete their activities, with fewer monetary costs, enhanced privacy and security. 

\section{Study Takeaways}
\label{sec:eval-study}

In Chapter \ref{chap:study}, we present the results of research conducted through an online questionnaire focused on the problem of assessing user's perceptions of blockchain-based technologies. We have, in Chapter \ref{chap:study}, made an initial evaluation of the results, while answering the design questions that had been stated. It is relevant, at this moment, that we evaluate the results of that component of this research as a whole and integrated with the rest of the thesis. We discuss some of the research limitations in Section \ref{sec:eval-limitations}. Throughout Chapter \ref{chap:study}, we have focused on answering the questions that had been proposed as design questions, ignoring how the results can be globally interpreted and effect a larger picture.

Our results allow us to infer that blockchain knowledge, at large, is still at a primitive stage. This situation is concerning for many of the potential applications of blockchain-based technologies (see Section \ref{sec:related-blockchain}), particularly due to the fact that most of our sample consisted of subjects integrated with technological industries or roles. There's an educational aspect, of users, that seems to be creating a knowledge gap between those that work \emph{with} blockchain-based technologies and those that will potentially use it. From the standpoint of application developers, this knowledge gap might represent increased overhead with user support and difficulty marketing application's core functionality, apart from the fact that they are based on blockchain-based technologies. After all, a blockchain is nothing but a single technological component of a system, similar to how a database would be a component of a complete system. Blockchains offer different features that must be understood in order to be used correctly and in order to be usable. This aspect is also relevant when considering the development of systems relying on blockchains because it suggests that, apart from supporting users in the usage of an application, users must also be supported and educated into matters relevant to blockchains, in particular.

In terms of security, we have presented results that allow us to infer that users perceive applications based on blockchains as more secure, when compared with other alternatives, such as databases. The fact that users perceive blockchain-based technologies in this manner allows us to argue that they would adopt applications and systems built for security or enhancing existing security systems, with blockchain. Users considered a system with a blockchain more secure than other systems, considered, on average, each interaction between entities more secure using a blockchain-based system than another system and, finally, considered that the most secure scenario was the one where a blockchain-based system was used. This represents a notion, from users, unequivocally for this sample, that blockchain-based systems are more secure. Nonetheless, as some respondents outlined in questions that were open-ended, the specifics of a solution, the context and the use case might not be particularly suitable for using blockchain. Due to that fact, there will be cases in which, although potentially more secure, blockchain usage might not be justified. In our research, we understand that the usage is justified. Some of the respondents, in their open-ended questions, suggested that encrypting the information would improve security, as well as allow for data to not be stored in plain text. We have included some of those suggestions in our final artifact but there are still aspects to improve in terms of usability.

With any technology, there's always a possibility that it will be perceived as complex, at an initial stage. We have seen, from the responses to our questionnaire, that users perceive blockchain to be a complex technology. This relates, possibly, to the education argument we have laid out in a previous paragraph. If users have less knowledge of the technology, that will increase the potential of them perceiving it as more complex. Nonetheless, this result represents a statement: that applications built on top of blockchains should focus their efforts on explaining and marketing the application and not the underlying technology. At the same time, it is remarkably important that developers consider this situation to improve on the usability of their products, by removing as much complexity from it as possible. A perception of complexity can be a hurdle in the adoption of a technology, or application, which means it should be considered while developing those applications. We have tried to do that by removing as much blockchain-related information from the applications users execute in \texttt{Blocked}, focusing instead on the information related to the use case of the application. An example of that is removing the concept of a user being associated with a specific blockchain address.

We have used this questionnaire throughout the design of our artifact. We have concluded that users perceive applications based on blockchains as potentially more secure but more complex as well. This has consequences for application development. It means that those applications must be tailored to be particularly simple, possibly bypassing the mention of the underlying technology used, similar to what we usually do with other application backbones, such as databases. We have aimed at focusing the artifact's scripts on the task at hand, not relying on having to explain blockchain technology to users but rather using it solely as a technological component in our toolbox.

This study presents an overlap between several areas of research: Information Security, Blockchain, Educational Certificates and Human Perception. We sought to explore how those interact by conducting an online questionnaire followed by a study that would shed some light over how users perceive blockchain technology, in terms of security and complexity, in an Educational Certificate use case. The results have indicated a tendency for users to perceive blockchain technology as more secure but, alas, more complex too - at least in this particular domain. This research is a starting point to better understand how humans perceive blockchain technology.

\section{Access Control Evaluation}
\label{sec:eval-ac}

In this section, we evaluate our system through the metrics proposed in \cite{hu_guidelines_2012} which is a continuation of what has been presented in \cite{hu_assessment_2006}. Leveraging these metrics allows us to have an understanding of what the access control system is capable of executing, against some known organizational metrics. An example of the usage of these metrics in other research pertaining to access control exists \cite{LE2014184}, which further supports our usage of these metrics to evaluate the access control system. As \citeauthor{hu_guidelines_2012} \cite{hu_guidelines_2012} establish, \emph{"the quality metric should be evaluated based on the specific needs for the AC policy"} \cite[25]{hu_guidelines_2012}. In our context, what this means is that rather than evaluating every single metric, with several of them being clearly inadequate, we should evaluate the subset of policies that seem adequate to our use case. We have provided a summary of all the metrics we are evaluating in Table \ref{tab:qualityMetrics}. Questions in 4.1.7 and 4.1.9, in Table \ref{tab:qualityMetrics}, have been rephrased to aggregate the existing section's questions into one question.

{
\renewcommand{\arraystretch}{1.5}%
\begin{table}[h]
	\centering
	\small

	\caption{Quality Metrics for Evaluation}
	\label{tab:qualityMetrics}
	\begin{tabular}{l|l}
		\hline \bf Section & \bf Metric Items                                                                                                      \\ \hline
		\rowcolor{lightgray} \multicolumn{2}{l}{Administration Properties}                                                                         \\ \hline
		4.1.1              & \llap{\textbullet} Does the AC system log denied access requests?                                                     \\
		                   & \llap{\textbullet} Does the AC system log granted access requests?                                                    \\ \hline
		4.1.2              & \llap{\textbullet} Does the system provide query/display for privileges discovery?                                    \\
		                   & \llap{\textbullet} Does the system provide graphic display?                                                           \\ \hline
		4.1.3              & \llap{\textbullet} How many steps are required for assigning a privilege?                                             \\
		                   & \llap{\textbullet} How many steps are required for removing a privilege?                                              \\ \hline
		4.1.4              & \llap{\textbullet} Is the AC system capable of logical expression for rule specification?                             \\ \hline
		4.1.5              & \llap{\textbullet} Does the AC system allow policy expiration assignment?                                             \\
		                   & \llap{\textbullet} Does the AC system provide policy deployment or activation verification?                           \\
		                   & \llap{\textbullet} Does the AC system allow runtime policy rule change?                                               \\ \hline
		4.1.7              & \llap{\textbullet} How is the AC enforced?                                                                            \\ \hline
		4.1.8              & \llap{\textbullet} Does the AC system support multiple hosts via network?                                             \\ \hline
		4.1.9              & \llap{\textbullet} What is the scope of data control?                                                                 \\
		\hline \rowcolor{lightgray} \multicolumn{2}{l}{Enforcement Properties}                                                                     \\ \hline
		4.2.2              & \llap{\textbullet} Is the AC system capable of bypassing policy rules for critical AC decisions?                      \\ \hline
		4.2.3              & \llap{\textbullet} Is the AC system capable of enforcing the least privilege principle?                               \\ \hline
		4.2.4              & \llap{\textbullet} Is the AC system capable of specifying Static SoD rules?                                           \\ \hline
		4.2.5              & \llap{\textbullet} Does the AC system provide safety check capabilities to prevent leaking of permissions?            \\ \hline
		4.2.6              & \llap{\textbullet} Does the AC system allow configuring the granularity of controlled objects?                        \\ \hline
		4.2.7              & \llap{\textbullet} Does the AC system support existing AC standards?                                                  \\
		\hline \rowcolor{lightgray} \multicolumn{2}{l}{Performance Properties}                                                                     \\ \hline
		4.3.1              & \llap{\textbullet} Does the response time of granting an access request meet the organization’s requirement?          \\ \hline
		4.3.2              & \llap{\textbullet} Does the AC policy retrieval and deposit meet the organization’s requirements?                     \\ \hline
		4.3.3              & \llap{\textbullet} Does the AC system provide an AC policy distribution mechanism?                                    \\ \hline
		4.3.4              & \llap{\textbullet} Can the AC system be integrated with or support identification authentication systems?             \\
		\hline \rowcolor{lightgray} \multicolumn{2}{l}{Support Properties}                                                                         \\ \hline
		4.4.2              & \llap{\textbullet} Is the AC system capable of supporting a different OS beside the one used by the intended host(s)? \\ \hline
		4.4.4              & \llap{\textbullet} Does the AC system provide a GUI or an API for AC policy management and authoring?                 \\
		\hline
	\end{tabular}
\end{table}
}

\subsection{Administration Properties}

\texttt{Blocked} audits the granting of access through the processing that happens inside the Transaction Processor. If the transactions submitted are approved, these are then stored in the blockchain. If, in turn, the transactions are rejected, the nodes will have a log that a given transaction has been rejected, along with the reason. This occurs because each node will process the transaction thus storing whether the transaction has been rejected. At the same time, each client performs the needed validations for accessing a certificate, which means that denied read accesses won't be logged anywhere, except on the client node's system.

The auditing that gets stored is only per transaction, apart from all the information that can be stored in a transaction (such as allowing or revoking a given access), there are no more logs available.  In terms of permissions' querying, users can query permissions only by iterating the blockchain. The system does not provide a way of querying permissions, neither from a terminal or GUI. Users may only iterate the transaction log, through the REST API, and reconstruct what permissions have been granted and revoked, reaching a final state of what permissions exist at a given point in time.

Assigning or removing a privilege is possible by executing the respective Python script, as described in Chapter \ref{chap:implementation}. In both cases - assigning and removing - it takes only one step to execute, apart from knowing the public identity of whoever is related to the permission. Nonetheless, updating a permission is impossible.

The system does not support the specification of \gls{ac} rules nor can't it handle any rule specification logic - such as \texttt{AND} and \texttt{OR}. Nonetheless, this situation doesn't appear as a weakness, due to the fact that, in the context we have described, the system has been designed, and implemented, to be used in a 1-to-1 basis. What this means is the system is implemented to deal with a given subject allowing another subject access to reading specific information. In this situation, not being able to support the specification of rules or handle any rule specification logic, doesn't seem to be something that is relevant.

\texttt{Blocked} does not for policy expiration assignment, by which a subject would cease to have permissions to a given object by the expiration of the policy. This feature would be useful in our context which makes it relevant enough to be considered a weakness, that could be improved in future time. It does allow for target assignments, given that the default policy is directly assigned to a given target - although there's no other way of executing policy assignment unless targeting a specific subject. \texttt{Blocked} allows for runtime policy changes, in the sense that it allows a permission to be revoked during runtime. For example, policies can change interactively while the nodes are running the validation network and, immediately before, a user queries for the information on a certificate.

In \texttt{Blocked}, the access control is enforced via a combination of application logic, consensus protocols and cryptography - as described in Chapter \ref{chap:design}. For viewing a certificate, a subject will need to possess the appropriate RSA secret key, otherwise, it won't be able to decrypt the data. For granting a permission, a subject also needs to have appropriate secret keys but, at the same time, needs to be either the issuer or recipient of a given certificate, otherwise, the transaction will be rejected by the Transaction Processor running in the nodes. Given that we are decentralizing access control, it makes sense to not have all enforcement as application logic. The reliance on consensus protocols is crucial, in order to maintain the integrity of the access. If all access control were to be enforced at the application logic, there would be no authority to validate a node's claim of being granted access to a specific subject.

The system supports an array of hosts, theoretically with a high dimension of availability, each running its own Transaction Processor, that will connect via the network. Each node will have a copy of the entire blockchain, which makes it functional when the node is a party to validation of transactions and when it is not a party to that.

The system covers application data that is stored inside a blockchain. In a way, the system protects structured or unstructured information that is stored, encrypted, on a blockchain. The use case is that of educational certificates but it would not be hard to extend or adapt, that information to being related to a different use case.

\subsection{Enforcement Properties}

In \texttt{Blocked}, it is currently theoretically possible to bypass the system by changing the code of the Transaction Processor and running a changed version on the network. Nonetheless, it would still have to bypass the consensus of the network because it would need to emit new policies - there's no way of bypassing the existing policies. This is difficult because several Transaction Processors running different versions of the code would result in rejected transactions. So, in practice, it is not possible to bypass the \gls{ac} system for crucial decisions. On the viewer, it would be extremely hard to bypass the system due to the fact that all the data is encrypted and secret keys, only known to the subjects, would be needed to decrypt that information. Nonetheless, possessing those keys would allow a user to bypass the system.

Every subject is considered as having no access unless it can decrypt one of the permissions, which means they have been granted access to that certificate. Granting access to a certificate grants access to only that certificate and no other on the system. At the same time, decryption of a certificate's symmetric key will prove useless when decrypting any other certificate, due to the fact that every certificate is encrypted with a different, randomly generated, key. The same argument can be made for \gls{sod}. Given that, in our model, subjects are given access only to certificates they are working with, in this case, verifying, confirming that \emph{"object accesses are only permitted to the subjects that are duty
	-related to the objects"} \cite[17]{hu_guidelines_2012}.

There's a universal constraint on the system that enforces that only subjects that have the secret keys, corresponding to the public keys, that were granted access to can access the information. This prevents leakage of permissions. In case a secret key is compromised, that permission should be revoked during runtime. At the same time, in the blockchain, no information is stored in plain-text which prevents the leakage of information through inspecting the blockchain.

The system granularity is statically configured to the certificate object, it doesn't support any other granularity. It would be a strength if, for example, recipients of several certificates were able to configure permissions for those certificate at a different granularity level.

Since the system was designed and implemented, for a very specific use case, and is still at a prototype stage, there's no support for existing access control standards. These would have introduced complexity throughout the design and development that would have diverged those activities from their initial goals, as well as implementation overhead.

\subsection{Performance Properties}

We have not assessed response times, policy retrieval and deposit, experimentally. In \texttt{Blocked}, policies are distributed through a peer-to-peer communication between the nodes. After each node has validated the transaction, and the transaction is deemed valid, the data is updated accordingly in its copy of the blockchain. Lastly, authentication is performed on the basis of public key cryptography, through the use of public keys as identities. Currently, \texttt{Blocked} doesn't integrate or support any other authentication systems.

\subsection{Support Properties}

The system supports only Ubuntu 18.04 LTS. Given that the system relies on the usage of Docker and Python - tools compatible with other operating systems - it seems trivial to extend support for those systems. Nonetheless, extensive OS compatibility tests have not been conducted thus support is not guaranteed. It would be important to perform this testing and needed modifications as it would strengthen the artifact.

In \texttt{Blocked}, usage is performed through command-line interfaces, for each of the existing scripts. Hyperledger Sawtooth also provides us with a REST API that can be used to query the underlying blockchain. Nonetheless, there's no \gls{gui} or API to perform policy management. These would be relevant improvements to consider in \texttt{Blocked}. It would also be interesting to consider developing a \gls{gui} to perform other activities, such as viewing information pertaining to a certificate.

\section{Research Limitations}
\label{sec:eval-limitations}

In this section, we discuss relevant research limitations in the work presented. We discuss those limitations on 3 specific topics: limitations of the study, described in Chapter \ref{chap:study}; limitations of the design and architecture of \texttt{Blocked}, described in Chapter \ref{chap:design}; and limitations of the implementation of \texttt{Blocked}, described in Chapter \ref{chap:implementation}.

\subsection{Limitations of Study}

It is important to note that this is a small sample, less than 50 respondents. This situation can give rise to erroneous results due to a biased sampling. At the same time, although we have some diversity, we would like to decrease the volume of one specific field when compared to others and gather a more diverse collection of respondents. This limitation can be overcome by reproducing the questionnaire on larger, more diverse samples. The fact that the subjects we are studying eschew heavily towards a more technically-driven professional area is also a reason for concern because it doesn't allow for analyzing conclusive tendencies without future studies. We aimed at reaching a bigger, more diverse sample, by speaking with subjects from different backgrounds, and publicizing the questionnaire in non-technical venues, alas we weren't as successful. At the same time, this is an exploratory study on the subject and we see this sample as being strong enough to validate the potential for further studies in this area.

We would also like to leave a note regarding the possibility of a learning bias. Although we have shuffled our scenarios, we have only done that with 2 out of the 3 scenarios. In the questionnaires that were presented, the Blockchain scenario always appeared as the last scenario to be analyzed. This creates a situation in which the results are not sustainable without future studies. In order to be able to get more conclusive data, it would be important to perform different studies where more shuffling was involved, particularly with anything involving blockchain - which we have kept in the last position, in both versions. More shuffling can either mean: \textit{(i)} more options with a randomized sequence; \textit{(ii)} repeating this questionnaire with just varying the last scenario and using it at the beginning, for example. It is worth noting, nonetheless, that this situation was an attempt at an equilibrium. Given that the study consisted of 3 scenarios, we had 6 possible permutations to decide on a sequence. With 2 versions only we were maximizing the distribution by allowing for a greater number of respondents to answer each version. Had we used 6 different versions, with the same number of respondents, we would have had less 8 respondents for each version, which is definitively low. This way we were able to gather a more significant number of answers for each version.

Finally, the platform used for the questionnaire had two limitations: \textit{(i)} a back button, which allowed respondents to rewrite their answers; \textit{(ii)} the impossibility to present the images of the interactions along with the questions - which might increase the confusion in respondents, by having to memorize the images. This isn't necessarily an issue with the study itself but it is rather a technological limitation we faced that we would rather correct in future studies.

\subsection{Limitations of Design and Architecture}

The technological architecture, presented in Chapter \ref{chap:design}, is highly coupled with the existing implementation, presented in Chapter \ref{chap:implementation}, based on Hyperledger Sawtooth. We have extensively used the term peer when representing a node in the network, have never mentioned the term \emph{mining}, which is common in other blockchain-based designs, relying on different platforms, and we have used the concept of \emph{state}, in the network, in a similar way to what Hyperledger Sawtooth presents. The chosen addressing schemes and cryptographic schemes are also tightly coupled with what Hyperledger Sawtooth currently supports. This presents a limitation because it might prevent the implementation of the system under different platforms, losing flexibility.

The underlying consensus algorithm - \gls{poet} - needs deeper evaluation and can be a limitation for the entire system. \gls{poet} is a fairly recent consensus protocol, which has been in development by Intel since 2015 and is currently only used on a reduced amount of projects. An early evaluation of the algorithm has found some vulnerabilities that can be mitigated \cite{chen_security_2017} but further studies need to be conducted. \gls{poet} is designed to achieve consensus efficiently, consuming less electricity, \emph{"using new secure CPU instructions which are becoming widely available in consumer and enterprise processors"} \cite{intel_poet}. In theory, this consensus mechanism would be more suitable for organizational environments. Nonetheless, if the algorithm is found to be irrevocably insecure or inefficient, with further evaluation, it won't be able to support the systems relying on it.

In the system's state, a property named \texttt{owners} has the public identities of both the issuer and recipient of a certificate. This property allows anyone, looking at the information directly on the blockchain, to know who is the issuer and recipient, albeit not knowing which is which. This component exists to allow the validator nodes to process requests for access control management, identifying whom the recipient is and validating it can submit those operations. Since validation nodes do not have access to the encrypted information, inside the certificate, this component provides that information without encryption. This is a limitation because it exposes some information, instead of having every bit of information concealed, which would be the ideal situation.

\subsection{Limitations of Implementation}

At this moment, the implementation doesn't provide a complete package that a user can execute in one step. Users need to set up the Docker environment, as well as have Python installed on their machine, so they can run a node and interact with the network. At the same time, existing Docker configurations don't allow users to point at specific peers which would force users to modify the images for each network they want to participate in. This is a usability issue for users. A more integrated environment, that requires less technical operations to be able to use the system would help increase adoption. Since it is still an exploratory implementation, the activities described are still being performed through a command-line Python script, visualization of the blockchain, results of the operations and current state are all still very rudimentary, with potential improvements both in user experience, as well as performance. Another limitation is the management of key pairings. At the moment, there's a need to use two sets of keys, a DSA-based key pair and an RSA-based key pair. This is cumbersome to do, especially since there are no auxiliary tools that would help a user achieve this.